#!/usr/bin/env python
# encoding: utf-8
import sys
import os
import logging

from beanstalkc import *

logging.basicConfig(level=logging.DEBUG, format=u'%(asctime)-15s %(name)-12s: %(levelname)-8s %(message)s')
LOG = logging.getLogger('queueit')
LOG.setLevel(logging.DEBUG)


# Loading values from the shell ENV
QHOST = os.environ.get('QUEUEIT_HOST', '127.0.0.1')
QPORT = 11300
QTIMEOUT = None

try:
    QTTR = int(os.environ.get('QUEUEIT_TTR', 120))
except ValueError:
    LOG.error("Incorect value for QUEUEIT_TTR. Using '%s' instead" % QTTR)

try:
    QPORT = int(os.environ.get('QUEUEIT_PORT', 11300))
except ValueError:
    LOG.error("Incorect value for QUEUEIT_PORT. Using '%s' instead" % QPORT)

try:
    QTIMEOUT = os.environ.get('QUEUEIT_TIMEOUT', QTIMEOUT)
    if QTIMEOUT:
        QTIMEOUT = int(QTIMEOUT)
except ValueError:
    LOG.error("Incorect value for QTIMEOUT. Using '%s' instead" % QTIMEOUT)


def _get_qconnection(host, port):
    try:
        return Connection(host=host, port=port)
    except SocketError:
        print "Can't connect to %s:%s" % (host, port)
        sys.exit(1)


def qget(tube_name, qconn=None):
    """
    Reserving job from the tube, printing the job.body and deleting that job.
    Be aware that job is already gone from the beanstalkd standpoint
    and operator have to deal with it.
    """
    if not qconn:
        qconn = _get_qconnection(QHOST, QPORT)

    qconn.watch(tube_name)
    job = qconn.reserve()
    print job.body
    job.delete()
    qconn.close()


def qput(tube_name, messages, qconn=None):
    if not qconn:
        qconn = _get_qconnection(QHOST, QPORT)

    for message in messages:
        qconn.use(tube_name)
        jobid = qconn.put(str(message), ttr=QTTR)
        print "OK: message=%s; tube=%s; job.id=%s; ttr=%s" % (message, tube_name, jobid, QTTR)
    qconn.close()


def qkick(tube_name, count=1, qconn=None):
    if not qconn:
        qconn = _get_qconnection(QHOST, QPORT)
    qconn.use(tube_name)
    print qconn.kick(count)


def qstat(qconn=None):
    if not qconn:
        qconn = _get_qconnection(QHOST, QPORT)
    #import pprint
    #pprint.pprint(qconn.stats())
    LINE="%-19s %-8s %-8s %-8s"
    print LINE % ('tube', 'watching', 'buried', 'ready')
    tubes = qconn.tubes()
    for tube in qconn.tubes():
        if tube:
           tube_stats = qconn.stats_tube(tube)
           #{'cmd-pause-tube': 0,
           # 'current-jobs-buried': 0,
           # 'current-jobs-delayed': 0,
           # 'current-jobs-ready': 0,
           # 'current-jobs-reserved': 0,
           # 'current-jobs-urgent': 0,
           # 'current-using': 0,
           # 'current-waiting': 1,
           # 'current-watching': 1,
           # 'name': 'object-extractor',
           # 'pause': 0,
           # 'pause-time-left': 0,
           # 'total-jobs': 0}
           print LINE % (tube,
                   tube_stats.get('current-watching'),
                   tube_stats.get('current-jobs-buried'),
                   tube_stats.get('current-jobs-ready'))


def qwrapper(tube_in, tube_out, worker_cmd):
    import subprocess
    qconn_in  = _get_qconnection(QHOST, QPORT)
    qconn_out = _get_qconnection(QHOST, QPORT)
    qconn_in.watch(tube_in)
    qconn_out.use(tube_out)

    LOG.info(u"Watching queues: %s" % qconn_in.watching())

    while True:
        job = qconn_in.reserve(timeout=QTIMEOUT)
        if not job:
            LOG.info(u"Timeout reached. Bye-bye")
            sys.exit()
        params = job.body

        #log_id = uuid4().hex
        #log_redirect = "> %s/%s.log 2>&1" % (LOG_DIR, log_id)
        #cmd = '%s "%s" %s' % (Q_CMD, params, log_redirect)

        cmd = '%s "%s"' % (worker_cmd, params)
        LOG.debug(u"Calling command %s" % cmd)
        retcode = subprocess.call(cmd, shell=True)
        if not retcode == 0:
            LOG.error(u"Worker command was exited with retcode %s" % retcode)
            job.bury()
            LOG.info(u"Job %s buried" % job.jid)
        else:
            jid = qconn_out.put(str(params))
            job.delete()
            LOG.info(u"New job put in to %s: %s" % (tube_out, jid))



if __name__ == "__main__":
    COMMAND = os.path.basename(sys.argv[0])
    args = sys.argv[1:]
    if COMMAND == 'queueit':
        if len(sys.argv) == 1:
            print "Usage:"
            print "%s q-get" % COMMAND
            print "%s q-put" % COMMAND
            print "%s q-kick" % COMMAND
            print "%s q-stat" % COMMAND
            print "%s q-wrapper" % COMMAND
            sys.exit(1)
        else:
            COMMAND = os.path.basename(sys.argv[1])
            args = sys.argv[2:]


    if COMMAND == 'q-get':
        if not len(args) == 1:
            print "q-get usage: %s <queue>" % (COMMAND)
            sys.exit(1)
        qget(args[0])
    elif COMMAND == 'q-put':
        if len(args) < 2:
            print "q-put usage: %s <queue> <message> [<message>, <message>]" % (sys.argv[0] )
            sys.exit(1)
        qput(args[0], args[1:])
    elif COMMAND == 'q-kick':
        if len(args) < 1 or len(args) > 2:
            print "q-kick usage: %s <queue> [<count>]"
            sys.exit(1)

        count = 1
        if len(args) == 2:
            try:
                count = int(args[1])
            except ValueError:
                print "Wrong count value '%s'. Using default %s" % (args[1], count)
        qkick(args[0], count)
    elif COMMAND == 'q-stat':
        qstat()
    elif COMMAND == 'q-wrapper':
        if len(args) < 3:
            print "q-wrapper usage: %s <queue-in> <queue-out> <cmd>" % (sys.argv[0])
            print sys.exit(1)
        qwrapper(args[0], args[1], args[2])
    else:
        print "Unknown command '%s'" % COMMAND

